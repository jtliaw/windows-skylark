# Skylark Screen Translator - Windows 免安装版本构建脚本
# PowerShell版本，可在本地Windows环境运行

param(
    [switch]$SkipDependencies,
    [switch]$SkipLanguagePacks,
    [string]$OutputDir = "dist",
    [switch]$CreateInstaller
)

# 颜色输出函数
function Write-ColorOutput {
    param(
        [string]$Message,
        [string]$ForegroundColor = "White"
    )
    Write-Host $Message -ForegroundColor $ForegroundColor
}

function Write-Success { param([string]$msg) Write-ColorOutput "✅ $msg" "Green" }
function Write-Info { param([string]$msg) Write-ColorOutput "ℹ️  $msg" "Cyan" }
function Write-Warning { param([string]$msg) Write-ColorOutput "⚠️  $msg" "Yellow" }
function Write-Error { param([string]$msg) Write-ColorOutput "❌ $msg" "Red" }

Write-Info "=== Skylark Screen Translator Windows 构建开始 ==="

# 检查系统要求
function Test-SystemRequirements {
    Write-Info "检查系统要求..."
    
    # 检查Python
    try {
        $pythonVersion = python --version 2>&1
        if ($pythonVersion -match "Python (\d+)\.(\d+)") {
            $major = [int]$matches[1]
            $minor = [int]$matches[2]
            if ($major -eq 3 -and $minor -ge 8) {
                Write-Success "Python版本: $pythonVersion"
            } else {
                throw "需要Python 3.8或更高版本"
            }
        }
    } catch {
        Write-Error "Python未安装或版本不符合要求"
        Write-Info "请安装Python 3.8+: https://www.python.org/downloads/"
        exit 1
    }
    
    # 检查pip
    try {
        pip --version | Out-Null
        Write-Success "pip已可用"
    } catch {
        Write-Error "pip不可用"
        exit 1
    }
    
    # 检查Git（可选）
    try {
        git --version | Out-Null
        Write-Success "Git已可用"
    } catch {
        Write-Warning "Git不可用，某些功能可能受限"
    }
}

# 安装Tesseract OCR
function Install-TesseractOCR {
    Write-Info "检查并安装Tesseract OCR..."
    
    # 检查是否已安装
    $tesseractPaths = @(
        "C:\Program Files\Tesseract-OCR\tesseract.exe",
        "C:\Program Files (x86)\Tesseract-OCR\tesseract.exe"
    )
    
    $tesseractFound = $false
    foreach ($path in $tesseractPaths) {
        if (Test-Path $path) {
            Write-Success "Tesseract已安装: $path"
            $env:PATH = (Split-Path $path) + ";" + $env:PATH
            $tesseractFound = $true
            break
        }
    }
    
    if (-not $tesseractFound) {
        Write-Info "下载并安装Tesseract OCR..."
        
        $tesseractUrl = "https://github.com/UB-Mannheim/tesseract/releases/download/v5.3.3.20231005/tesseract-ocr-w64-setup-5.3.3.20231005.exe"
        $installerPath = "$env:TEMP\tesseract-installer.exe"
        
        try {
            Write-Info "下载Tesseract安装程序..."
            Invoke-WebRequest -Uri $tesseractUrl -OutFile $installerPath -UseBasicParsing
            
            Write-Info "安装Tesseract（静默安装）..."
            Start-Process -FilePath $installerPath -ArgumentList "/S" -Wait
            
            # 验证安装
            if (Test-Path "C:\Program Files\Tesseract-OCR\tesseract.exe") {
                $env:PATH = "C:\Program Files\Tesseract-OCR;" + $env:PATH
                Write-Success "Tesseract安装成功"
            } else {
                throw "Tesseract安装失败"
            }
            
            # 清理安装文件
            Remove-Item $installerPath -ErrorAction SilentlyContinue
            
        } catch {
            Write-Error "Tesseract安装失败: $_"
            Write-Info "请手动安装Tesseract: https://github.com/UB-Mannheim/tesseract/releases"
            exit 1
        }
    }
    
    # 下载语言包
    Write-Info "下载Tesseract语言包..."
    $tessdata = "C:\Program Files\Tesseract-OCR\tessdata"
    if (-not (Test-Path $tessdata)) {
        $tessdata = "C:\Program Files (x86)\Tesseract-OCR\tessdata"
    }
    
    if (Test-Path $tessdata) {
        $languages = @('chi_sim', 'chi_tra', 'jpn', 'kor', 'deu', 'fra', 'spa', 'rus', 'ara', 'hin')
        foreach ($lang in $languages) {
            $langFile = "$tessdata\$lang.traineddata"
            if (-not (Test-Path $langFile)) {
                try {
                    $url = "https://github.com/tesseract-ocr/tessdata/raw/main/$lang.traineddata"
                    Write-Info "下载语言包: $lang"
                    Invoke-WebRequest -Uri $url -OutFile $langFile -UseBasicParsing
                    Write-Success "语言包 $lang 下载完成"
                } catch {
                    Write-Warning "语言包 $lang 下载失败: $_"
                }
            } else {
                Write-Info "语言包 $lang 已存在"
            }
        }
    }
}

# 创建虚拟环境
function New-VirtualEnvironment {
    Write-Info "创建虚拟环境..."
    
    if (Test-Path "venv") {
        Write-Info "删除现有虚拟环境..."
        Remove-Item -Recurse -Force "venv"
    }
    
    python -m venv venv
    if (-not $?) {
        Write-Error "虚拟环境创建失败"
        exit 1
    }
    
    # 激活虚拟环境
    & "venv\Scripts\Activate.ps1"
    Write-Success "虚拟环境创建并激活成功"
    
    # 升级pip
    Write-Info "升级pip..."
    python -m pip install --upgrade pip setuptools wheel
}

# 安装Python依赖
function Install-PythonDependencies {
    Write-Info "安装Python依赖..."
    
    # 设置pip镜像（可选）
    $pipConfig = @"
[global]
index-url = https://pypi.tuna.tsinghua.edu.cn/simple/
trusted-host = pypi.tuna.tsinghua.edu.cn
timeout = 120
"@
    
    $pipDir = "$env:APPDATA\pip"
    if (-not (Test-Path $pipDir)) {
        New-Item -ItemType Directory -Force -Path $pipDir | Out-Null
    }
    $pipConfig | Out-File -FilePath "$pipDir\pip.ini" -Encoding UTF8
    
    # 核心依赖
    Write-Info "安装核心依赖..."
    $corePackages = @(
        "PyQt5==5.15.10",
        "Pillow>=9.0.0",
        "numpy>=1.21.0",
        "opencv-python-headless",
        "pytesseract",
        "mss",
        "pynput",
        "requests",
        "screeninfo", 
        "ttkthemes",
        "certifi",
        "pyinstaller"
    )
    
    foreach ($package in $corePackages) {
        Write-Info "安装: $package"
        pip install $package
        if (-not $?) {
            Write-Warning "包 $package 安装可能有问题，继续..."
        }
    }
    
    Write-Success "核心依赖安装完成"
}

# 安装ArgosTranslate
function Install-ArgosTranslate {
    if ($SkipLanguagePacks) {
        Write-Warning "跳过ArgosTranslate安装"
        return
    }
    
    Write-Info "安装ArgosTranslate离线翻译..."
    
    # 设置环境变量强制CPU版本
    $env:FORCE_CUDA = "0"
    $env:USE_CUDA = "0"
    
    try {
        # 安装PyTorch CPU版本
        Write-Info "安装PyTorch CPU版本..."
        pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cpu
        
        # 安装翻译依赖
        Write-Info "安装翻译依赖..."
        $translatePackages = @("PyYAML", "sentencepiece", "stanza", "ctranslate2")
        foreach ($package in $translatePackages) {
            Write-Info "安装: $package"
            pip install $package
        }
        
        # 安装ArgosTranslate
        Write-Info "安装ArgosTranslate..."
        pip install argostranslate
        
        Write-Success "ArgosTranslate安装完成"
        
    } catch {
        Write-Error "ArgosTranslate安装失败: $_"
        Write-Warning "继续构建，但离线翻译功能可能不可用"
    }
}

# 下载语言包
function Install-LanguagePacks {
    if ($SkipLanguagePacks) {
        Write-Warning "跳过语言包下载"
        return
    }
    
    Write-Info "下载ArgosTranslate语言包..."
    
    $pythonScript = @"
import sys
import argostranslate.package
import argostranslate.translate

try:
    print('更新包索引...')
    argostranslate.package.update_package_index()
    
    available_packages = argostranslate.package.get_available_packages()
    print(f'找到 {len(available_packages)} 个可用包')
    
    # 选择要安装的语言对
    desired_langs = ['en', 'zh', 'ja', 'ko', 'de', 'fr', 'es']
    target_packages = [
        pkg for pkg in available_packages
        if pkg.from_code in desired_langs and pkg.to_code in desired_langs
    ]
    
    installed_count = 0
    max_packages = 15  # 限制数量避免构建时间过长
    
    for i, pkg in enumerate(target_packages[:max_packages]):
        try:
            print(f'[{i+1}/{min(len(target_packages), max_packages)}] 安装: {pkg.from_code} -> {pkg.to_code}')
            download_path = pkg.download()
            argostranslate.package.install_from_path(download_path)
            installed_count += 1
            print('✅ 安装成功')
        except Exception as e:
            print(f'❌ 安装失败: {e}')
    
    print(f'\n成功安装 {installed_count} 个语言包')
    
    # 验证安装
    installed_packages = argostranslate.package.get_installed_packages()
    print(f'已安装的包: {len(installed_packages)}')
    for pkg in installed_packages:
        print(f'  - {pkg.from_code} -> {pkg.to_code}')
        
    # 测试翻译
    if installed_packages:
        test_pkg = None
        for pkg in installed_packages:
            if pkg.from_code == 'en' and pkg.to_code == 'zh':
                test_pkg = pkg
                break
        
        if test_pkg:
            result = argostranslate.translate.translate('Hello world', 'en', 'zh')
            print(f'\n测试翻译: Hello world -> {result}')
            print('✅ 翻译功能验证成功')
        
except Exception as e:
    print(f'语言包安装过程出错: {e}')
    print('基础框架仍然可用')
    sys.exit(0)  # 不要因为语言包失败而中断整个构建
"@

    $pythonScript | python
    Write-Success "语言包下载完成"
}

# 检查和增强源文件
function Test-SourceFiles {
    Write-Info "检查源文件..."
    
    $requiredFiles = @("skylark_screen_translator.py")
    $missingFiles = @()
    
    foreach ($file in $requiredFiles) {
        if (-not (Test-Path $file)) {
            $missingFiles += $file
        }
    }
    
    if ($missingFiles.Count -gt 0) {
        Write-Error "缺少必要文件:"
        foreach ($file in $missingFiles) {
            Write-Error "  - $file"
        }
        exit 1
    }
    
    # 检查online_translator.py
    if (-not (Test-Path "online_translator.py")) {
        Write-Info "创建增强的online_translator.py..."
        New-EnhancedOnlineTranslator
    } else {
        Write-Info "online_translator.py已存在，创建增强版本..."
        Copy-Item "online_translator.py" "online_translator_backup.py"
        New-EnhancedOnlineTranslator
    }
    
    Write-Success "源文件检查完成"
}

# 创建增强的online_translator.py
function New-EnhancedOnlineTranslator {
    $translatorCode = @'
#!/usr/bin/env python3
"""
Enhanced Online Translator with ArgosTranslate support
Windows版本，兼容Skylark Screen Translator
"""

import os
import sys
import logging
from typing import List, Dict, Optional, Any

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class OnlineTranslator:
    """增强的翻译器，支持ArgosTranslate离线翻译"""
    
    def __init__(self):
        self.name = "Enhanced Translator (Windows)"
        self.installed_packages = []
        self.argos_available = False
        self.initialize_argos()
        
    def initialize_argos(self):
        """初始化ArgosTranslate"""
        try:
            import argostranslate.package
            import argostranslate.translate
            
            self.argos_package = argostranslate.package
            self.argos_translate = argostranslate.translate
            self.installed_packages = self.argos_package.get_installed_packages()
            self.argos_available = True
            
            logger.info(f"ArgosTranslate初始化成功，已安装 {len(self.installed_packages)} 个语言包")
            
            # 打印已安装的包
            for pkg in self.installed_packages:
                logger.debug(f"已安装: {pkg.from_code} -> {pkg.to_code}")
                
        except ImportError as e:
            logger.warning(f"ArgosTranslate不可用: {e}")
            self.argos_available = False
        except Exception as e:
            logger.error(f"ArgosTranslate初始化失败: {e}")
            self.argos_available = False
            
    def translate(self, text: str, source_lang: str = 'auto', target_lang: str = 'en') -> str:
        """主要翻译方法"""
        if not text or not text.strip():
            return text
            
        try:
            # 尝试使用ArgosTranslate离线翻译
            if self.argos_available and hasattr(self, 'argos_translate'):
                # 语言代码转换
                source_lang = self._normalize_lang_code(source_lang, text)
                target_lang = self._normalize_lang_code(target_lang)
                
                # 检查是否有main函数
            if hasattr(skylark_screen_translator, 'main'):
                skylark_screen_translator.main()
            elif hasattr(skylark_screen_translator, 'app'):
                # 如果有app对象，直接运行
                app = skylark_screen_translator.app
                sys.exit(app.exec_())
            else:
                # 尝试执行模块
                logger.info("以模块方式执行主程序")
                exec(open('skylark_screen_translator.py').read())
                
        except ImportError as e:
            logger.error(f"无法导入主模块: {e}")
            # 尝试直接执行文件
            main_script = os.path.join(os.path.dirname(__file__), 'skylark_screen_translator.py')
            if os.path.exists(main_script):
                logger.info("尝试直接执行主脚本")
                with open(main_script, 'r', encoding='utf-8') as f:
                    exec(f.read())
            else:
                raise FileNotFoundError("找不到主程序文件")
                
    except Exception as e:
        logger.error(f"应用启动失败: {e}")
        traceback.print_exc()
        
        # 显示错误信息
        try:
            from PyQt5.QtWidgets import QApplication, QMessageBox
            import sys
            
            app = QApplication(sys.argv)
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setWindowTitle("Skylark Screen Translator - 启动错误")
            msg.setText(f"应用启动失败:\n\n{str(e)}")
            msg.setDetailedText(traceback.format_exc())
            msg.exec_()
            
        except:
            # 如果Qt也不可用，使用控制台输出
            print(f"启动错误: {e}")
            input("按Enter退出...")
        
        sys.exit(1)

if __name__ == '__main__':
    main()
'@
    
    $launcherCode | Out-File -FilePath "skylark_launcher.py" -Encoding UTF8
    Write-Success "Windows启动器创建完成"
}

# 创建PyInstaller规范文件
function New-PyInstallerSpec {
    Write-Info "创建PyInstaller规范文件..."
    
    $specCode = @'
# -*- mode: python ; coding: utf-8 -*-

import os
import sys
from PyInstaller.utils.hooks import collect_data_files, collect_submodules

block_cipher = None

# 收集隐藏导入
hiddenimports = [
    # PyQt5核心
    'PyQt5.QtCore', 'PyQt5.QtGui', 'PyQt5.QtWidgets', 
    'PyQt5.sip', 'sip',
    
    # 图像处理
    'PIL', 'PIL.Image', 'PIL.ImageGrab', 'PIL.ImageTk',
    'cv2', 'numpy', 'numpy.core._methods', 'numpy.lib.format',
    
    # OCR和屏幕捕获
    'pytesseract', 'mss', 'mss.windows', 
    'pynput', 'pynput.keyboard', 'pynput.mouse',
    'pynput.keyboard._win32', 'pynput.mouse._win32',
    'screeninfo',
    
    # Windows特定
    'win32gui', 'win32api', 'win32con', 'win32clipboard',
    
    # 网络和工具
    'requests', 'requests.packages.urllib3', 'certifi',
    'ttkthemes', 'json', 'hashlib', 'uuid',
    
    # 离线翻译
    'argostranslate', 'argostranslate.package', 'argostranslate.translate',
    'argostranslate.settings', 'argostranslate.utils',
    'stanza', 'ctranslate2', 'sentencepiece', 
    'torch', 'torch._C', 'torch.nn', 'torch.optim',
    
    # 自定义模块
    'online_translator',
    
    # 标准库
    'pkg_resources.py2_warn',
]

# 收集数据文件
datas = []

# 主程序文件
main_files = ['skylark_screen_translator.py', 'online_translator.py']
for file in main_files:
    if os.path.exists(file):
        datas.append((file, '.'))

# 图标文件
icon_files = ['skylark.png', 'skylark.ico', 'icon.png']
for icon in icon_files:
    if os.path.exists(icon):
        datas.append((icon, '.'))

# SSL证书
try:
    import certifi
    datas.append((certifi.where(), 'certifi'))
except:
    pass

# ArgosTranslate数据
try:
    import argostranslate
    import argostranslate.package
    
    # ArgosTranslate包目录
    argos_path = os.path.dirname(argostranslate.__file__)
    datas.append((argos_path, 'argostranslate'))
    
    # 语言包目录
    try:
        packages_path = argostranslate.package.get_package_path()
        if os.path.exists(packages_path) and os.listdir(packages_path):
            datas.append((packages_path, 'argos_packages'))
            print(f"包含ArgosTranslate语言包: {packages_path}")
    except:
        pass
        
    # 收集所有argostranslate子模块
    hiddenimports.extend(collect_submodules('argostranslate'))
    
except Exception as e:
    print(f"Warning: ArgosTranslate数据收集失败: {e}")

# Tesseract数据（如果可用）
tesseract_paths = [
    r'C:\Program Files\Tesseract-OCR\tessdata',
    r'C:\Program Files (x86)\Tesseract-OCR\tessdata'
]
for tess_path in tesseract_paths:
    if os.path.exists(tess_path):
        # 只包含主要语言包
        important_langs = ['eng.traineddata', 'chi_sim.traineddata', 'chi_tra.traineddata', 
                          'jpn.traineddata', 'kor.traineddata', 'deu.traineddata', 'fra.traineddata']
        for lang_file in important_langs:
            lang_path = os.path.join(tess_path, lang_file)
            if os.path.exists(lang_path):
                datas.append((lang_path, 'tessdata'))
        break

# PyTorch数据
try:
    import torch
    torch_data = collect_data_files('torch')
    for item in torch_data:
        if 'lib' in item[0] or '.so' in item[0] or '.dll' in item[0]:
            datas.append(item)
except:
    pass

a = Analysis(
    ['skylark_launcher.py'],
    pathex=[],
    binaries=[],
    datas=datas,
    hiddenimports=hiddenimports,
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[
        # 排除不需要的大型库
        'matplotlib', 'scipy', 'pandas', 'jupyter', 'notebook',
        'PyQt5.QtWebEngine', 'PyQt5.QtWebEngineWidgets',
        'tkinter', 'turtle', 'test', 'unittest',
        # CUDA相关（我们使用CPU版本）
        'torch.backends.cudnn', 'torch.cuda', 'cupy',
    ],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)

# 过滤二进制文件，移除不需要的DLL
a.binaries = [x for x in a.binaries if not (
    'api-ms-win-' in x[0].lower() or
    'ucrtbase' in x[0].lower() or
    'vcruntime' in x[0].lower()
)]

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name='Skylark_Screen_Translator',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    console=False,  # Windows应用，不显示控制台
    disable_windowed_traceback=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon='skylark.ico' if os.path.exists('skylark.ico') else None,
    version='version_info.txt' if os.path.exists('version_info.txt') else None,
)

coll = COLLECT(
    exe,
    a.binaries,
    a.zipfiles,
    a.datas,
    strip=False,
    upx=True,
    upx_exclude=[],
    name='Skylark_Screen_Translator',
)
'@

    $specCode | Out-File -FilePath "skylark_windows.spec" -Encoding UTF8
    Write-Success "PyInstaller规范文件创建完成"
}

# 构建应用
function Build-Application {
    Write-Info "构建Windows应用..."
    
    # 激活虚拟环境
    & "venv\Scripts\Activate.ps1"
    
    # 清理之前的构建
    if (Test-Path "dist") {
        Remove-Item -Recurse -Force "dist"
    }
    if (Test-Path "build") {
        Remove-Item -Recurse -Force "build"
    }
    
    # 使用PyInstaller构建
    Write-Info "运行PyInstaller..."
    python -m PyInstaller skylark_windows.spec --clean --noconfirm --log-level=INFO
    
    if ($LASTEXITCODE -ne 0) {
        Write-Error "PyInstaller构建失败"
        return $false
    }
    
    # 验证构建结果
    $exePath = "dist\Skylark_Screen_Translator\Skylark_Screen_Translator.exe"
    if (-not (Test-Path $exePath)) {
        Write-Error "构建的可执行文件不存在"
        return $false
    }
    
    Write-Success "应用构建完成: $exePath"
    return $true
}

# 创建便携版包
function New-PortablePackage {
    Write-Info "创建便携版包..."
    
    $portableDir = "Skylark_Portable"
    if (Test-Path $portableDir) {
        Remove-Item -Recurse -Force $portableDir
    }
    New-Item -ItemType Directory -Force -Path $portableDir | Out-Null
    
    # 复制应用文件
    $distDir = "dist\Skylark_Screen_Translator"
    if (-not (Test-Path $distDir)) {
        Write-Error "构建目录不存在: $distDir"
        return $false
    }
    
    Write-Info "复制应用文件..."
    Copy-Item -Recurse -Force "$distDir\*" $portableDir
    
    # 创建启动批处理文件
    Write-Info "创建启动脚本..."
    $batchContent = @'
@echo off
title Skylark Screen Translator
cd /d "%~dp0"

REM 设置环境变量
set PATH=%CD%;%CD%\tessdata;%PATH%
set QT_QPA_PLATFORM=windows
set TESSDATA_PREFIX=%CD%\tessdata

REM 检查依赖
if not exist "Skylark_Screen_Translator.exe" (
    echo 错误：找不到主程序文件
    pause
    exit /b 1
)

REM 启动程序（隐藏CMD窗口）
echo 启动 Skylark Screen Translator...
start "" "Skylark_Screen_Translator.exe"

REM 等待几秒钟确保程序启动
timeout /t 3 /nobreak >nul

REM 关闭批处理窗口
exit /b 0
'@
    $batchContent | Out-File -FilePath "$portableDir\Skylark_Screen_Translator.bat" -Encoding ASCII
    
    # 创建调试版启动脚本
    $debugBatch = @'
@echo off
title Skylark Screen Translator Debug
cd /d "%~dp0"

echo =================================
echo Skylark Screen Translator Debug
echo =================================
echo.

REM 设置环境变量
set PATH=%CD%;%CD%\tessdata;%PATH%
set QT_QPA_PLATFORM=windows
set TESSDATA_PREFIX=%CD%\tessdata

echo 环境变量设置完成
echo 当前目录: %CD%
echo PATH包含: %PATH%
echo.

REM 检查文件
if exist "Skylark_Screen_Translator.exe" (
    echo ✅ 找到主程序
) else (
    echo ❌ 未找到主程序
    pause
    exit /b 1
)

if exist "tessdata" (
    echo ✅ 找到Tesseract数据目录
) else (
    echo ⚠️ 未找到Tesseract数据目录
)

echo.
echo 启动程序...
echo 如果程序无法启动，请检查以下内容：
echo 1. Windows Defender是否阻止了程序
echo 2. 是否有杀毒软件误报
echo 3. 是否缺少Visual C++ Redistributable
echo.

REM 启动程序（保持CMD窗口）
"Skylark_Screen_Translator.exe"

echo.
echo 程序已退出，按任意键关闭此窗口...
pause >nul
'@
    $debugBatch | Out-File -FilePath "$portableDir\Debug_Start.bat" -Encoding ASCII
    
    # 创建配置文件
    Write-Info "创建配置文件..."
    $configContent = @'
# Skylark Screen Translator 配置文件
# Windows 便携版

[General]
Version=Windows_Portable
Platform=Windows
OCR_Engine=Tesseract
Translation_Engine=ArgosTranslate
Portable_Mode=true
Debug_Mode=false

[OCR]
Tesseract_Data_Path=./tessdata
Default_Language=eng
Auto_Language_Detection=true

[Translation]
Argos_Packages_Path=./argos_packages
Default_Source_Language=auto
Default_Target_Language=zh
Enable_Offline_Translation=true

[UI]
Theme=auto
Language=auto
Window_Always_On_Top=false
Auto_Hide_After_Translation=false

[Advanced]
Log_Level=INFO
Enable_Screenshot_History=true
Max_History_Items=100
Auto_Update_Check=false
'@
    $configContent | Out-File -FilePath "$portableDir\config.ini" -Encoding UTF8
    
    # 创建README文件
    Write-Info "创建说明文档..."
    $readmeContent = @"
# Skylark Screen Translator - Windows 便携版

## 🎯 软件简介
Skylark Screen Translator 是一款强大的屏幕翻译工具，支持离线OCR识别和翻译功能。

## ✨ 主要特性
- 🔍 离线OCR文字识别 (Tesseract引擎)
- 🌐 离线翻译功能 (ArgosTranslate引擎)  
- 📸 屏幕截图翻译
- 🗣️ 多语言支持
- 📦 免安装，解压即用
- 🚀 轻量级，启动快速

## 🚀 使用方法

### 快速启动
1. 解压到任意目录
2. 双击 `Skylark_Screen_Translator.bat` 启动程序
3. 或直接运行 `Skylark_Screen_Translator.exe`

### 调试模式
如果程序无法正常启动，请使用 `Debug_Start.bat` 查看详细信息。

## 🌍 支持语言

### OCR识别
- English (英语)
- 中文简体 / 繁体
- 日本語 (日语) 
- 한국어 (韩语)
- Deutsch (德语)
- Français (法语)
- Español (西班牙语)
- Русский (俄语)

### 翻译语言
- 支持上述OCR语言之间的互译
- 自动语言检测
- 智能翻译优化

## ⚙️ 系统要求
- Windows 7 SP1 / 8 / 10 / 11
- RAM: 最少512MB可用内存
- 磁盘: 约200MB可用空间
- 显示器: 支持1024x768分辨率

## 🔧 故障排除

### 常见问题
1. **程序无法启动**
   - 检查Windows Defender是否阻止了程序
   - 确认杀毒软件没有误报
   - 尝试以管理员身份运行

2. **OCR识别不准确**
   - 确保截图区域文字清晰
   - 尝试调整截图区域大小
   - 检查语言设置是否正确

3. **翻译功能异常**
   - 首次使用可能需要下载语言包
   - 检查网络连接（在线翻译）
   - 尝试使用离线翻译模式

4. **缺少Visual C++ Redistributable**
   - 下载并安装最新的 Microsoft Visual C++ Redistributable
   - 链接: https://aka.ms/vs/17/release/vc_redist.x64.exe

### 日志文件
程序运行日志保存在同目录下的 `logs` 文件夹中，出现问题时可查看详细信息。

## 📝 更新日志
- 支持完整离线翻译
- 优化Windows兼容性  
- 修复PIL.ImageGrab问题
- 增强错误处理和调试信息
- 改进便携版部署

## 🔗 项目信息
- 项目地址: https://github.com/jtliaw/Skylark-Screen-Translator
- 构建时间: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
- 构建环境: PowerShell构建脚本
- 版本类型: Windows便携版

## 📄 许可证
请查看项目仓库了解许可证信息。

## 🆘 技术支持
如遇问题，请访问项目GitHub页面提交Issue或查看已有解决方案。

---
感谢使用 Skylark Screen Translator！
"@
    $readmeContent | Out-File -FilePath "$portableDir\README.txt" -Encoding UTF8
    
    Write-Success "便携版包创建完成: $portableDir"
    return $true
}

# 创建安装包（可选）
function New-Installer {
    if (-not $CreateInstaller) {
        Write-Info "跳过安装包创建"
        return
    }
    
    Write-Info "创建Windows安装包..."
    
    # 检查是否安装了NSIS
    $nsisPath = Get-Command "makensis.exe" -ErrorAction SilentlyContinue
    if (-not $nsisPath) {
        Write-Warning "未找到NSIS，跳过安装包创建"
        Write-Info "要创建安装包，请安装NSIS: https://nsis.sourceforge.io/"
        return
    }
    
    # 创建NSIS脚本
    $nsisScript = @'
!include "MUI2.nsh"
!include "FileAssociation.nsh"

Name "Skylark Screen Translator"
OutFile "Skylark_Screen_Translator_Setup.exe"
InstallDir "$PROGRAMFILES\Skylark Screen Translator"
RequestExecutionLevel admin

; 界面配置
!define MUI_ABORTWARNING
!define MUI_ICON "${NSISDIR}\Contrib\Graphics\Icons\modern-install.ico"

; 安装页面
!insertmacro MUI_PAGE_WELCOME
!insertmacro MUI_PAGE_LICENSE "LICENSE.txt"
!insertmacro MUI_PAGE_DIRECTORY
!insertmacro MUI_PAGE_INSTFILES
!insertmacro MUI_PAGE_FINISH

; 卸载页面
!insertmacro MUI_UNPAGE_WELCOME
!insertmacro MUI_UNPAGE_CONFIRM
!insertmacro MUI_UNPAGE_INSTFILES
!insertmacro MUI_UNPAGE_FINISH

; 语言文件
!insertmacro MUI_LANGUAGE "English"
!insertmacro MUI_LANGUAGE "SimpChinese"

Section "Main Application" SecMain
    SetOutPath "$INSTDIR"
    File /r "Skylark_Portable\*.*"
    
    ; 创建快捷方式
    CreateDirectory "$SMPROGRAMS\Skylark Screen Translator"
    CreateShortCut "$SMPROGRAMS\Skylark Screen Translator\Skylark Screen Translator.lnk" "$INSTDIR\Skylark_Screen_Translator.exe"
    CreateShortCut "$DESKTOP\Skylark Screen Translator.lnk" "$INSTDIR\Skylark_Screen_Translator.exe"
    
    ; 注册卸载程序
    WriteUninstaller "$INSTDIR\Uninstall.exe"
    WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\SkylarkTranslator" "DisplayName" "Skylark Screen Translator"
    WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\SkylarkTranslator" "UninstallString" "$INSTDIR\Uninstall.exe"
SectionEnd

Section "Uninstall"
    Delete "$INSTDIR\*.*"
    RMDir /r "$INSTDIR"
    Delete "$SMPROGRAMS\Skylark Screen Translator\*.*"
    RMDir "$SMPROGRAMS\Skylark Screen Translator"
    Delete "$DESKTOP\Skylark Screen Translator.lnk"
    DeleteRegKey HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\SkylarkTranslator"
SectionEnd
'@
    
    $nsisScript | Out-File -FilePath "installer.nsi" -Encoding ASCII
    
    # 运行NSIS编译
    & "makensis.exe" "installer.nsi"
    
    if ($LASTEXITCODE -eq 0) {
        Write-Success "安装包创建成功: Skylark_Screen_Translator_Setup.exe"
    } else {
        Write-Error "安装包创建失败"
    }
}

# 压缩便携版
function Compress-PortablePackage {
    Write-Info "压缩便携版包..."
    
    $portableDir = "Skylark_Portable"
    if (-not (Test-Path $portableDir)) {
        Write-Error "便携版目录不存在"
        return
    }
    
    # 创建ZIP压缩包
    $zipName = "Skylark_Screen_Translator_Windows_Portable.zip"
    if (Test-Path $zipName) {
        Remove-Item $zipName -Force
    }
    
    Write-Info "创建ZIP压缩包..."
    Compress-Archive -Path "$portableDir\*" -DestinationPath $zipName -CompressionLevel Optimal
    
    if (Test-Path $zipName) {
        $size = [math]::Round((Get-Item $zipName).Length / 1MB, 2)
        Write-Success "ZIP压缩包创建完成: $zipName (${size}MB)"
    }
    
    # 尝试创建7z压缩包（如果7z可用）
    $sevenZip = Get-Command "7z.exe" -ErrorAction SilentlyContinue
    if ($sevenZip) {
        $sevenZipName = "Skylark_Screen_Translator_Windows_Portable.7z"
        Write-Info "创建7z压缩包..."
        & "7z.exe" a -t7z -mx=9 $sevenZipName "$portableDir\*"
        
        if ($LASTEXITCODE -eq 0 -and (Test-Path $sevenZipName)) {
            $size7z = [math]::Round((Get-Item $sevenZipName).Length / 1MB, 2)
            Write-Success "7z压缩包创建完成: $sevenZipName (${size7z}MB)"
        }
    } else {
        Write-Info "7-Zip不可用，跳过7z压缩包创建"
    }
}

# 测试应用
function Test-Application {
    Write-Info "测试应用..."
    
    $exePath = "Skylark_Portable\Skylark_Screen_Translator.exe"
    if (-not (Test-Path $exePath)) {
        Write-Error "可执行文件不存在: $exePath"
        return $false
    }
    
    Write-Info "验证文件完整性..."
    $requiredFiles = @(
        "Skylark_Portable\Skylark_Screen_Translator.exe",
        "Skylark_Portable\Skylark_Screen_Translator.bat", 
        "Skylark_Portable\Debug_Start.bat",
        "Skylark_Portable\config.ini",
        "Skylark_Portable\README.txt"
    )
    
    $allFound = $true
    foreach ($file in $requiredFiles) {
        if (Test-Path $file) {
            Write-Success "✅ $file"
        } else {
            Write-Error "❌ $file"
            $allFound = $false
        }
    }
    
    if ($allFound) {
        Write-Success "文件完整性检查通过"
        
        # 尝试快速启动测试（仅启动几秒钟）
        try {
            Write-Info "尝试启动测试（5秒后自动关闭）..."
            $process = Start-Process -FilePath $exePath -PassThru
            Start-Sleep -Seconds 5
            if (-not $process.HasExited) {
                $process.CloseMainWindow()
                Start-Sleep -Seconds 2
                if (-not $process.HasExited) {
                    $process.Kill()
                }
            }
            Write-Success "应用启动测试通过"
        } catch {
            Write-Warning "启动测试失败（可能需要GUI环境）: $_"
        }
        
        return $true
    } else {
        return $false
    }
}

# 显示构建结果
function Show-BuildResults {
    Write-Info "=== 构建结果 ==="
    
    # 显示生成的文件
    $outputFiles = @()
    
    if (Test-Path "Skylark_Portable") {
        $portableSize = (Get-ChildItem "Skylark_Portable" -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB
        $outputFiles += "📁 Skylark_Portable/ (${portableSize:F1}MB) - 便携版文件夹"
    }
    
    if (Test-Path "Skylark_Screen_Translator_Windows_Portable.zip") {
        $zipSize = (Get-Item "Skylark_Screen_Translator_Windows_Portable.zip").Length / 1MB
        $outputFiles += "📦 Skylark_Screen_Translator_Windows_Portable.zip (${zipSize:F1}MB)"
    }
    
    if (Test-Path "Skylark_Screen_Translator_Windows_Portable.7z") {
        $sevenZSize = (Get-Item "Skylark_Screen_Translator_Windows_Portable.7z").Length / 1MB
        $outputFiles += "📦 Skylark_Screen_Translator_Windows_Portable.7z (${sevenZSize:F1}MB) - 更小"
    }
    
    if (Test-Path "Skylark_Screen_Translator_Setup.exe") {
        $setupSize = (Get-Item "Skylark_Screen_Translator_Setup.exe").Length / 1MB
        $outputFiles += "🔧 Skylark_Screen_Translator_Setup.exe (${setupSize:F1}MB) - 安装程序"
    }
    
    if ($outputFiles.Count -gt 0) {
        Write-Success "生成的文件:"
        foreach ($file in $outputFiles) {
            Write-Info "  $file"
        }
    } else {
        Write-Warning "未找到生成的文件"
    }
    
    Write-Info ""
    Write-Info "🎯 使用说明:"
    Write-Info "1. 便携版: 解压后双击 Skylark_Screen_Translator.bat"
    Write-Info "2. 如有问题: 使用 Debug_Start.bat 查看详细信息"
    Write-Info "3. 配置文件: config.ini"
    Write-Info "4. 说明文档: README.txt"
    
    Write-Info ""
    Write-Info "🔧 故障排除:"
    Write-Info "- Windows Defender警告: 添加到信任列表"
    Write-Info "- 启动失败: 以管理员身份运行"
    Write-Info "- 缺少依赖: 安装 Visual C++ Redistributable"
    
    Write-Success "=== Windows构建完成！==="
}

# 主执行流程
function Main {
    try {
        # 检查系统要求
        Test-SystemRequirements
        
        # 检查源文件
        Test-SourceFiles
        
        if (-not $SkipDependencies) {
            # 安装Tesseract OCR
            Install-TesseractOCR
            
            # 创建虚拟环境
            New-VirtualEnvironment
            
            # 安装Python依赖
            Install-PythonDependencies
            
            # 安装ArgosTranslate
            Install-ArgosTranslate
            
            # 下载语言包
            Install-LanguagePacks
        }
        
        # 创建Windows启动器
        New-WindowsLauncher
        
        # 创建PyInstaller规范文件
        New-PyInstallerSpec
        
        # 构建应用
        if (-not (Build-Application)) {
            Write-Error "应用构建失败"
            exit 1
        }
        
        # 创建便携版包
        if (-not (New-PortablePackage)) {
            Write-Error "便携版包创建失败"
            exit 1
        }
        
        # 创建安装包（可选）
        New-Installer
        
        # 压缩便携版
        Compress-PortablePackage
        
        # 测试应用
        Test-Application
        
        # 显示构建结果
        Show-BuildResults
        
        Write-Success "所有构建步骤完成！"
        
    } catch {
        Write-Error "构建过程中出现错误: $_"
        Write-Error "错误详情: $($_.Exception.Message)"
        Write-Error "错误位置: $($_.ScriptStackTrace)"
        exit 1
    }
}

# 清理函数
function Cleanup {
    Write-Info "清理临时文件..."
    
    $tempItems = @("build", "*.spec", "__pycache__", "*.pyc")
    foreach ($item in $tempItems) {
        if (Test-Path $item) {
            Remove-Item -Recurse -Force $item -ErrorAction SilentlyContinue
        }
    }
    
    Write-Info "清理完成"
}

# 帮助信息
function Show-Help {
    Write-Host @"
Skylark Screen Translator - Windows 构建脚本

用法: .\build_windows.ps1 [参数]

参数:
  -SkipDependencies     跳过依赖安装（用于重新构建）
  -SkipLanguagePacks    跳过ArgosTranslate语言包下载
  -OutputDir <path>     指定输出目录（默认: dist）
  -CreateInstaller      创建NSIS安装程序
  -Help                 显示此帮助信息

示例:
  .\build_windows.ps1                          # 完整构建
  .\build_windows.ps1 -SkipDependencies        # 跳过依赖安装
  .\build_windows.ps1 -CreateInstaller         # 创建安装程序
  .\build_windows.ps1 -SkipLanguagePacks       # 跳过语言包下载

要求:
  - Windows 7+ 
  - Python 3.8+
  - 管理员权限（安装Tesseract时需要）

输出:
  - Skylark_Portable/                          # 便携版文件夹
  - Skylark_Screen_Translator_Windows_Portable.zip  # ZIP压缩包
  - Skylark_Screen_Translator_Windows_Portable.7z   # 7z压缩包（如果有7-Zip）
  - Skylark_Screen_Translator_Setup.exe        # 安装程序（可选）

项目地址: https://github.com/jtliaw/Skylark-Screen-Translator
"@
}

# 参数处理
if ($args -contains "-Help" -or $args -contains "--help" -or $args -contains "/?" -or $args -contains "-h") {
    Show-Help
    exit 0
}

# 运行主函数
try {
    Write-Info "Skylark Screen Translator Windows构建脚本启动"
    Write-Info "构建时间: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
    Write-Info "PowerShell版本: $($PSVersionTable.PSVersion)"
    Write-Info "操作系统: $([System.Environment]::OSVersion.VersionString)"
    Write-Info ""
    
    # 检查执行策略
    $executionPolicy = Get-ExecutionPolicy
    if ($executionPolicy -eq "Restricted") {
        Write-Warning "PowerShell执行策略受限，可能需要调整"
        Write-Info "运行: Set-ExecutionPolicy RemoteSigned -Scope CurrentUser"
    }
    
    # 运行主逻辑
    Main
    
} catch {
    Write-Error "脚本执行失败: $_"
    exit 1
} finally {
    # 清理临时文件
    if (-not $args.Contains("-NoCleanup")) {
        Cleanup
    }
    
    Write-Info ""
    Write-Info "构建脚本执行完成"
    Write-Info "结束时间: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
}有对应的语言包
                available_pair = self._find_translation_pair(source_lang, target_lang)
                if available_pair:
                    result = self.argos_translate.translate(text, source_lang, target_lang)
                    if result and result != text:
                        logger.info(f"ArgosTranslate翻译成功: {source_lang}->{target_lang}")
                        return result
                        
                # 如果没有直接的语言包，尝试通过英语中转
                if source_lang != 'en' and target_lang != 'en':
                    en_pair = self._find_translation_pair(source_lang, 'en')
                    target_pair = self._find_translation_pair('en', target_lang)
                    
                    if en_pair and target_pair:
                        logger.info(f"尝试通过英语中转: {source_lang}->en->{target_lang}")
                        en_result = self.argos_translate.translate(text, source_lang, 'en')
                        if en_result:
                            final_result = self.argos_translate.translate(en_result, 'en', target_lang)
                            if final_result:
                                logger.info("英语中转翻译成功")
                                return final_result
                                
        except Exception as e:
            logger.error(f"翻译失败: {e}")
            
        # 如果所有方法都失败，返回带标记的原文
        logger.warning("所有翻译方法失败，返回原文")
        return f"[翻译失败] {text}"
        
    def _normalize_lang_code(self, lang_code: str, text: str = None) -> str:
        """标准化语言代码"""
        if lang_code == 'auto' and text:
            return self._detect_language(text)
            
        # 语言代码映射
        lang_mapping = {
            'zh-cn': 'zh', 'zh-tw': 'zh', 'chinese': 'zh',
            'japanese': 'ja', 'korean': 'ko', 'german': 'de',
            'french': 'fr', 'spanish': 'es', 'russian': 'ru',
            'italian': 'it', 'portuguese': 'pt', 'arabic': 'ar',
            'hindi': 'hi', 'english': 'en'
        }
        
        return lang_mapping.get(lang_code.lower(), lang_code.lower())
        
    def _detect_language(self, text: str) -> str:
        """简单的语言检测"""
        if any('\u4e00' <= char <= '\u9fff' for char in text):
            return 'zh'  # 中文
        elif any('\u3040' <= char <= '\u309f' or '\u30a0' <= char <= '\u30ff' for char in text):
            return 'ja'  # 日文  
        elif any('\uac00' <= char <= '\ud7af' for char in text):
            return 'ko'  # 韩文
        elif any('\u0400' <= char <= '\u04ff' for char in text):
            return 'ru'  # 俄文
        else:
            return 'en'  # 默认英文
            
    def _find_translation_pair(self, from_lang: str, to_lang: str) -> bool:
        """查找是否有对应的翻译包"""
        for pkg in self.installed_packages:
            if pkg.from_code == from_lang and pkg.to_code == to_lang:
                return True
        return False
        
    def get_available_translators(self) -> List[Dict[str, str]]:
        """获取可用翻译器列表"""
        translators = []
        
        if self.argos_available and self.installed_packages:
            # 基于已安装包创建翻译器选项
            added_pairs = set()
            for pkg in self.installed_packages:
                pair_key = f"{pkg.from_code}_{pkg.to_code}"
                if pair_key not in added_pairs:
                    translators.append({
                        'name': f"argos_{pkg.from_code}_to_{pkg.to_code}",
                        'display_name': f"ArgosTranslate: {self._get_language_name(pkg.from_code)} → {self._get_language_name(pkg.to_code)}",
                        'from_lang': pkg.from_code,
                        'to_lang': pkg.to_code,
                        'type': 'offline'
                    })
                    added_pairs.add(pair_key)
        
        # 添加通用离线翻译选项
        if self.argos_available:
            translators.insert(0, {
                'name': 'argos_auto',
                'display_name': 'ArgosTranslate (智能离线翻译)',
                'from_lang': 'auto',
                'to_lang': 'auto',
                'type': 'offline'
            })
        
        # 如果没有可用翻译器，提供备用选项
        if not translators:
            translators = [{
                'name': 'fallback',
                'display_name': '基础翻译器 (离线)',
                'from_lang': 'auto',
                'to_lang': 'en',
                'type': 'fallback'
            }]
            
        logger.info(f"返回 {len(translators)} 个可用翻译器")
        return translators
        
    def get_supported_languages(self) -> Dict[str, str]:
        """获取支持的语言列表"""
        languages = {
            'auto': '自动检测',
            'en': 'English', 'zh': '中文', 'ja': '日本語', 'ko': '한국어',
            'de': 'Deutsch', 'fr': 'Français', 'es': 'Español', 'ru': 'Русский',
            'it': 'Italiano', 'pt': 'Português', 'ar': 'العربية', 'hi': 'हिन्दी',
            'th': 'ไทย', 'vi': 'Tiếng Việt', 'tr': 'Türkçe', 'pl': 'Polski',
            'nl': 'Nederlands', 'sv': 'Svenska', 'da': 'Dansk', 'no': 'Norsk',
            'fi': 'Suomi', 'cs': 'Čeština', 'el': 'Ελληνικά', 'uk': 'Українська'
        }
        
        # 根据已安装包添加额外语言
        if hasattr(self, 'installed_packages'):
            for pkg in self.installed_packages:
                if pkg.from_code not in languages:
                    languages[pkg.from_code] = pkg.from_code.upper()
                if pkg.to_code not in languages:
                    languages[pkg.to_code] = pkg.to_code.upper()
                    
        return languages
        
    def get_translator_languages(self, translator_name: str) -> Dict[str, Dict[str, str]]:
        """获取特定翻译器支持的语言"""
        supported = self.get_supported_languages()
        return {
            'source_languages': supported,
            'target_languages': supported
        }
        
    def is_available(self) -> bool:
        """检查翻译器是否可用"""
        return self.argos_available and len(self.installed_packages) > 0
        
    def _get_language_name(self, lang_code: str) -> str:
        """获取语言显示名称"""
        names = {
            'en': 'English', 'zh': '中文', 'ja': '日本語', 'ko': '한국어',
            'de': 'Deutsch', 'fr': 'Français', 'es': 'Español', 'ru': 'Русский',
            'it': 'Italiano', 'pt': 'Português', 'ar': 'العربية', 'hi': 'हिन्दी',
            'th': 'ไทย', 'vi': 'Tiếng Việt', 'tr': 'Türkçe', 'pl': 'Polski'
        }
        return names.get(lang_code, lang_code.upper())

# 创建默认翻译器实例
default_translator = OnlineTranslator()

# 兼容性函数，用于与主程序接口
def get_available_translators() -> List[Dict[str, str]]:
    """获取可用翻译器（全局函数）"""
    return default_translator.get_available_translators()

def get_translator_languages(translator_name: str) -> Dict[str, Dict[str, str]]:
    """获取翻译器语言（全局函数）"""
    return default_translator.get_translator_languages(translator_name)

def is_translator_available(translator_name: str = None) -> bool:
    """检查翻译器是否可用（全局函数）"""
    return default_translator.is_available()

def translate_text(text: str, source_lang: str = 'auto', target_lang: str = 'en', translator_name: str = None) -> str:
    """翻译文本（全局函数）"""
    return default_translator.translate(text, source_lang, target_lang)

# 向后兼容的类别名
Translator = OnlineTranslator

if __name__ == '__main__':
    # 测试代码
    translator = OnlineTranslator()
    
    print("=== Skylark Online Translator 测试 ===")
    print(f"ArgosTranslate可用: {translator.argos_available}")
    print(f"已安装语言包: {len(translator.installed_packages)}")
    
    translators = translator.get_available_translators()
    print(f"可用翻译器: {len(translators)}")
    for t in translators[:5]:  # 显示前5个
        print(f"  - {t['display_name']}")
    
    languages = translator.get_supported_languages()
    print(f"支持语言: {len(languages)} 种")
    
    # 测试翻译
    test_cases = [
        ("Hello world", "en", "zh"),
        ("你好世界", "zh", "en"),
        ("This is a test", "auto", "zh")
    ]
    
    print("\n=== 翻译测试 ===")
    for text, src, tgt in test_cases:
        try:
            result = translator.translate(text, src, tgt)
            print(f"{src}->{tgt}: '{text}' → '{result}'")
        except Exception as e:
            print(f"{src}->{tgt}: '{text}' → 错误: {e}")
            
    print("\n=== 测试完成 ===")
'@

    $translatorCode | Out-File -FilePath "online_translator.py" -Encoding UTF8
    Write-Success "增强的online_translator.py创建完成"
}

# 创建Windows启动器
function New-WindowsLauncher {
    Write-Info "创建Windows启动器..."
    
    $launcherCode = @'
#!/usr/bin/env python3
"""
Skylark Screen Translator - Windows启动器
处理Windows特有的环境配置和依赖问题
"""

import os
import sys
import traceback
import logging

# 配置日志
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def setup_windows_environment():
    """配置Windows运行环境"""
    try:
        app_dir = os.path.dirname(os.path.abspath(__file__))
        logger.info(f"应用目录: {app_dir}")
        
        # 设置Tesseract路径
        tesseract_paths = [
            r'C:\Program Files\Tesseract-OCR',
            r'C:\Program Files (x86)\Tesseract-OCR',
            os.path.join(app_dir, 'tesseract'),
            os.path.join(app_dir, '_internal', 'tesseract')
        ]
        
        tesseract_found = False
        for path in tesseract_paths:
            tesseract_exe = os.path.join(path, 'tesseract.exe')
            if os.path.exists(tesseract_exe):
                if path not in os.environ['PATH']:
                    os.environ['PATH'] = path + os.pathsep + os.environ['PATH']
                os.environ['TESSERACT_CMD'] = tesseract_exe
                logger.info(f"Tesseract找到: {tesseract_exe}")
                tesseract_found = True
                break
        
        if not tesseract_found:
            logger.warning("未找到Tesseract，OCR功能可能不可用")
        
        # 设置Qt环境
        os.environ['QT_QPA_PLATFORM'] = 'windows'
        os.environ['QT_AUTO_SCREEN_SCALE_FACTOR'] = '0'
        
        # Qt插件路径
        qt_plugin_paths = [
            os.path.join(app_dir, '_internal', 'PyQt5', 'Qt5', 'plugins'),
            os.path.join(app_dir, '_internal', 'PyQt5', 'Qt', 'plugins'),
            os.path.join(app_dir, 'PyQt5', 'Qt5', 'plugins')
        ]
        
        for plugin_path in qt_plugin_paths:
            if os.path.exists(plugin_path):
                os.environ['QT_QPA_PLATFORM_PLUGIN_PATH'] = plugin_path
                os.environ['QT_PLUGIN_PATH'] = plugin_path
                logger.info(f"Qt插件路径: {plugin_path}")
                break
        
        # SSL证书配置
        try:
            import certifi
            cert_file = certifi.where()
            os.environ['SSL_CERT_FILE'] = cert_file
            os.environ['REQUESTS_CA_BUNDLE'] = cert_file
            logger.info(f"SSL证书: {cert_file}")
        except ImportError:
            logger.warning("certifi模块不可用")
        
        # ArgosTranslate包目录
        argos_paths = [
            os.path.join(app_dir, '_internal', 'argos_packages'),
            os.path.join(app_dir, 'argos_packages'),
            os.path.join(os.path.expanduser('~'), '.local', 'share', 'argostranslate', 'packages')
        ]
        
        for argos_path in argos_paths:
            if os.path.exists(argos_path):
                os.environ['ARGOS_PACKAGES_DIR'] = argos_path
                logger.info(f"ArgosTranslate包目录: {argos_path}")
                break
        
        # Python路径配置
        internal_path = os.path.join(app_dir, '_internal')
        if os.path.exists(internal_path):
            sys.path.insert(0, internal_path)
            
        sys.path.insert(0, app_dir)
        
        logger.info("Windows环境配置完成")
        
    except Exception as e:
        logger.error(f"环境配置失败: {e}")
        traceback.print_exc()

def check_dependencies():
    """检查关键依赖"""
    missing_deps = []
    
    try:
        import PyQt5
        logger.info("PyQt5: OK")
    except ImportError:
        missing_deps.append("PyQt5")
    
    try:
        import PIL
        logger.info("PIL: OK") 
    except ImportError:
        missing_deps.append("PIL/Pillow")
    
    try:
        import pytesseract
        logger.info("pytesseract: OK")
    except ImportError:
        missing_deps.append("pytesseract")
    
    try:
        import argostranslate
        logger.info("argostranslate: OK")
    except ImportError:
        logger.warning("argostranslate: 不可用（离线翻译功能受限）")
    
    if missing_deps:
        logger.error(f"缺少依赖: {', '.join(missing_deps)}")
        return False
    
    return True

def main():
    """主启动函数"""
    try:
        logger.info("=== Skylark Screen Translator 启动中 ===")
        
        # 配置环境
        setup_windows_environment()
        
        # 检查依赖
        if not check_dependencies():
            input("依赖检查失败，按Enter退出...")
            sys.exit(1)
        
        # 导入并启动主应用
        logger.info("启动主应用...")
        
        try:
            # 尝试导入主模块
            import skylark_screen_translator
            
            # 检查是否
